<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>404 Page not found | 모조 로그</title><meta name="generator" content="Hugo 0.88.1" /><meta name="robots" content="noindex, nofollow" /><link href="/assets/style.css" rel="stylesheet" /></head><body><div class="position-fixed text-white bg-secondary bg-gradient text-wrap" style="z-index: -1"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"> <code class="language-go" data-lang="go"> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> <span style="color:#75715e">// Copyright 2019 The Hugo Authors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &#34;AS IS&#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package hugolib import ( &#34;bytes&#34; &#34;fmt&#34; &#34;html/template&#34; &#34;path&#34; &#34;reflect&#34; &#34;regexp&#34; &#34;sort&#34; &#34;strconv&#34; &#34;strings&#34; &#34;sync&#34; &#34;github.com/gohugoio/hugo/helpers&#34; &#34;github.com/gohugoio/hugo/common/herrors&#34; &#34;github.com/pkg/errors&#34; &#34;github.com/gohugoio/hugo/parser/pageparser&#34; &#34;github.com/gohugoio/hugo/resources/page&#34; &#34;github.com/gohugoio/hugo/common/maps&#34; &#34;github.com/gohugoio/hugo/common/text&#34; &#34;github.com/gohugoio/hugo/common/urls&#34; &#34;github.com/gohugoio/hugo/output&#34; bp &#34;github.com/gohugoio/hugo/bufferpool&#34; &#34;github.com/gohugoio/hugo/tpl&#34; ) var ( _ urls.RefLinker = (*ShortcodeWithPage)(nil) _ pageWrapper = (*ShortcodeWithPage)(nil) _ text.Positioner = (*ShortcodeWithPage)(nil) ) // ShortcodeWithPage is the &#34;.&#34; context in a shortcode template. type ShortcodeWithPage struct { Params interface{} Inner template.HTML Page page.Page Parent *ShortcodeWithPage Name string IsNamedParams bool // Zero-based ordinal in relation to its parent. If the parent is the page itself, // this ordinal will represent the position of this shortcode in the page content. Ordinal int // pos is the position in bytes in the source file. Used for error logging. posInit sync.Once posOffset int pos text.Position scratch *maps.Scratch } // Position returns this shortcode&#39;s detailed position. Note that this information // may be expensive to calculate, so only use this in error situations. func (scp *ShortcodeWithPage) Position() text.Position { scp.posInit.Do(func() { if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok { scp.pos = p.posOffset(scp.posOffset) } }) return scp.pos } // Site returns information about the current site. func (scp *ShortcodeWithPage) Site() page.Site { return scp.Page.Site() } // Ref is a shortcut to the Ref method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) { return scp.Page.RefFrom(args, scp) } // RelRef is a shortcut to the RelRef method on Page. It passes itself as a context // to get better error messages. func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) { return scp.Page.RelRefFrom(args, scp) } // Scratch returns a scratch-pad scoped for this shortcode. This can be used // as a temporary storage for variables, counters etc. func (scp *ShortcodeWithPage) Scratch() *maps.Scratch { if scp.scratch == nil { scp.scratch = maps.NewScratch() } return scp.scratch } // Get is a convenience method to look up shortcode parameters by its key. func (scp *ShortcodeWithPage) Get(key interface{}) interface{} { if scp.Params == nil { return nil } if reflect.ValueOf(scp.Params).Len() == 0 { return nil } var x reflect.Value switch key.(type) { case int64, int32, int16, int8, int: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { idx := int(reflect.ValueOf(key).Int()) ln := reflect.ValueOf(scp.Params).Len() if idx &gt; ln-1 { return &#34;&#34; } x = reflect.ValueOf(scp.Params).Index(idx) } case string: if reflect.TypeOf(scp.Params).Kind() == reflect.Map { x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key)) if !x.IsValid() { return &#34;&#34; } } else if reflect.TypeOf(scp.Params).Kind() == reflect.Slice { // We treat this as a non error, so people can do similar to // {{ $myParam := .Get &#34;myParam&#34; | default .Get 0 }} // Without having to do additional checks. return nil } } return x.Interface() } func (scp *ShortcodeWithPage) page() page.Page { return scp.Page } // Note - this value must not contain any markup syntax const shortcodePlaceholderPrefix = &#34;HAHAHUGOSHORTCODE&#34; func createShortcodePlaceholder(id string, ordinal int) string { return shortcodePlaceholderPrefix + &#34;-&#34; + id + strconv.Itoa(ordinal) + &#34;-HBHB&#34; } type shortcode struct { name string isInline bool // inline shortcode. Any inner will be a Go template. isClosing bool // whether a closing tag was provided inner []interface{} // string or nested shortcode params interface{} // map or array ordinal int err error info tpl.Info // One of the output formats (arbitrary) templs []tpl.Template // All output formats // If set, the rendered shortcode is sent as part of the surrounding content // to Blackfriday and similar. // Before Hug0 0.55 we didn&#39;t send any shortcode output to the markup // renderer, and this flag told Hugo to process the {{ .Inner }} content // separately. // The old behaviour can be had by starting your shortcode template with: // {{ $_hugo_config := `{ &#34;version&#34;: 1 }`}} doMarkup bool // the placeholder in the source when passed to Blackfriday etc. // This also identifies the rendered shortcode. placeholder string pos int // the position in bytes in the source file length int // the length in bytes in the source file } func (s shortcode) insertPlaceholder() bool { return !s.doMarkup || s.configVersion() == 1 } func (s shortcode) configVersion() int { if s.info == nil { // Not set for inline shortcodes. return 2 } return s.info.ParseInfo().Config.Version } func (s shortcode) innerString() string { var sb strings.Builder for _, inner := range s.inner { sb.WriteString(inner.(string)) } return sb.String() } func (sc shortcode) String() string { // for testing (mostly), so any change here will break tests! var params interface{} switch v := sc.params.(type) { case map[string]interface{}: // sort the keys so test assertions won&#39;t fail var keys []string for k := range v { keys = append(keys, k) } sort.Strings(keys) tmp := make(map[string]interface{}) for _, k := range keys { tmp[k] = v[k] } params = tmp default: // use it as is params = sc.params } return fmt.Sprintf(&#34;%s(%q, %t){%s}&#34;, sc.name, params, sc.doMarkup, sc.inner) } type shortcodeHandler struct { p *pageState s *Site // Ordered list of shortcodes for a page. shortcodes []*shortcode // All the shortcode names in this set. nameSet map[string]bool // Configuration enableInlineShortcodes bool } func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler { sh := &amp;shortcodeHandler{ p: p, s: s, enableInlineShortcodes: s.enableInlineShortcodes, shortcodes: make([]*shortcode, 0, 4), nameSet: make(map[string]bool), } return sh } const ( innerNewlineRegexp = &#34; &#34; innerCleanupRegexp = `A&lt;p&gt;(.*)&lt;/p&gt; z` innerCleanupExpand = &#34;$1&#34; ) func renderShortcode( level int, s *Site, tplVariants tpl.TemplateVariants, sc *shortcode, parent *ShortcodeWithPage, p *pageState) (string, bool, error) { var tmpl tpl.Template // Tracks whether this shortcode or any of its children has template variations // in other languages or output formats. We are currently only interested in /</span> </code> </pre></div></div><style>code,pre{white-space:normal !important}</style><div class="row justify-content-center position-absolute" style="top: 40%; left: 40%;"><h1 class="text-white">We will find a way. We always have</h1><h2><a class="text-muted" href="/">Go Home</a></h2></div></body></html>
